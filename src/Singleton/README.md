概念
--
单例模式指的是一个类只有一个实例，且自行实例化向系统提供

实现方式
--
饿汉式
--
在类加载时就创建唯一实例

_**优点**_：

线程安全：在类加载时就创建实例，保证了在多线程环境下的唯一性，无需担心并发访问导致的线程安全问题。

简单明了：实现简单直接，代码量少，易于理解和维护。

无锁：由于在类加载时就创建实例，不涉及复杂的同步控制逻辑，因此没有额外的性能消耗。

**_缺点_**：

资源浪费：由于在类加载时就创建实例，如果该实例在后续的程序执行中未被使用到，会造成资源浪费。

无法延迟加载：饿汉式无法做到延迟加载，在类加载时就创建实例，即使在后续程序中可能用不到这个实例也会创建，不够灵活。

可能影响启动时间：如果单例对象初始化较为复杂，可能会影响应用程序的启动时间。

懒汉式
--
在第一次使用时才创建实例

**_优点_**：

延迟加载：懒汉式在第一次调用getInstance()方法时才创建实例，避免了在程序启动时就创建实例，能够节约资源。

灵活性：由于是延迟加载，可以根据需要选择在何时创建实例，更加灵活。

避免资源浪费：相比饿汉式，懒汉式不会因为在程序运行中未被使用的实例而造成资源浪费。

**_缺点_**：

线程安全：最简单的懒汉式实现在多线程环境下可能存在线程安全问题，可能会创建多个实例。

性能消耗：需要在getInstance()方法中增加同步控制逻辑以确保线程安全，可能带来性能上的消耗。

复杂度增加：需要考虑并发情况下的线程安全问题，使得代码的复杂度增加。

双重检查锁
--
第一次使用时才会创建（懒汉式），且保证线程安全性

**_优点_**：
延迟加载：只有在第一次调用获取实例方法时才会初始化实例，避免了提前初始化的开销。
减少同步开销：通过双重检查，在第一次检查时不需要进行同步操作，提高性能。
线程安全：通过volatile关键字和synchronized关键字保证了在多线程环境下创建唯一实例的正确性和可见性。

**_缺点_**：
复杂性：双重检查锁定模式相对于其他单例实现方式较为复杂，需要确保线程安全的同时防止出现错误。
可能引发指令重排问题：在早期的Java版本中，由于指令重排优化可能导致双重检查锁定失效，需要额外处理。
过度优化：在某些情况下，双重检查锁定可能会被认为是过度优化，对于某些应用场景可能并不需要这种级别的性能优化。

静态内部类
--
饿汉式创建，且线程安全

**_优点_**：
延迟加载：静态内部类只有在第一次被使用时才会被加载，实现了延迟加载。
线程安全：由于类加载过程是线程安全的，静态内部类方式天生具备线程安全性。
高效且简洁：代码清晰简洁，不需要额外的同步措施。
可维护性：通过静态内部类的封装性，更好地保护单例对象的状态。

**_缺点_**：
无法传递参数：静态内部类方式创建的单例对象不能接收参数，适用于无参数构造函数的情况。
破坏单例特性：反射机制可以通过访问私有构造函数来破坏单例特性，需要额外处理防御措施。
不支持延迟初始化：如果需要在初始化静态内部类时执行一些额外逻辑，则无法满足这种需求。

枚举
--
保证线程安全、反射安全、序列化
